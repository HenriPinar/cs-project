#!/usr/bin/env python
# coding: utf-8

# In[52]:


# pip installment for all relevant packages
get_ipython().system('pip install -q streamlit')
get_ipython().system('pip install -q streamlit --upgrade')
get_ipython().system('pip install -q pandas')
get_ipython().system('pip install -q numpy')
get_ipython().system('pip install -q matplotlib')
get_ipython().system('pip install streamlit_jupyter')
get_ipython().system('pip install google')
get_ipython().system('pip install googlemaps')


# In[388]:


get_ipython().run_cell_magic('writefile', 'CS.py', '\n# Import all relevant libraries \nimport streamlit as st\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport re\nimport math\nimport streamlit.components.v1 as components\nimport webbrowser\nfrom collections import Counter\nfrom googlesearch import search\nimport webbrowser\nimport time\nfrom sklearn.linear_model import LinearRegression\nimport requests\n\n# Streamlit Setup:\n\n# Set Tab Title\nst.set_page_config(\n    page_title="Cocktail up your Life",\n    page_icon="üç∏",\n)\n\n# Import and set Logo for the Application\nlogo_image = "Logo.png"\nst.image(logo_image, use_column_width=True)\n\n\n# Set Title & Intro\nst.write("<p style=\'text-align: center;\'>Welcome to Cocktail up your life, the interactive application that turns your leftovers into delicious drinks or just gives you nearby bar locations, if you are to lazy to shake yourself!</p>", unsafe_allow_html=True)\nst.markdown("<br>" * 1, unsafe_allow_html=True)\n\n# Define Help button for the ingredient selection\nhelp_button = \'\'\'\nSelect all the ingredients you have. Multiselect is possible.\n\'\'\'.strip()\n\n\n# Pre-Processing:\n\n# Import static Dataframe for Drinks\ndf_drink = pd.read_csv("iba-cocktails-ingredients-web.csv", delimiter=",")\n\n# Drop redundant Columns \ncolumns_to_drop = ["ingredient_direction", "note"]\ndf_drink = df_drink.drop(columns=columns_to_drop)\n\n# Form a Dictionary with names (keys) and ingredients (values)\ndrink_list = df_drink.iloc[:, 1].tolist()\ndrink_dict = dict(Counter(drink_list))\n\n# Define function to retrieve Weblinks for the missing ingredients\ndef search_products(products):\n    first_results = {}\n\n    for product in products:\n        query = f"{product} kaufen"\n        search_result = next(search(query, num=1, stop=1, pause=2), None)\n        first_results[product] = search_result\n    \n    return first_results\n\n# Setup sidebar to change views\nview_options = ["Find Your Drink", "Add Your Creation", "Find a nearby Bar"]\nselected_view = st.sidebar.radio("Select:", view_options)\n\n# Paragraph\nst.markdown("<br>" * 1, unsafe_allow_html=True)\n\n# View 1 - add your creation:\n\n\nif selected_view == "Add Your Creation":\n    \n    # Setup Title\n    st.title("Add your own creation ü™Ñ")\n    \n    # Initiate Text Input field for drink name\n    name_add = st.text_input("Add your Drink Name:")\n\n    # Initiate slider for ingredients count\n    selected_count_ingredients = st.slider(\'How many ingredients does the drink have?\', min_value=1, max_value=10, value=1)\n    \n    # Define empty list for user inputs\n    ingredient_list = []\n    quantity_list = []\n    unit_list = []\n    \n    # Since some filds are not defined until the user input we use try and except to hide the errors that occur\n    try: \n    \n        # Set up for-lop to iterate over the inputs and put them into the corresponding lists\n        def add_ingredient(ingredient_count):\n\n            for i in range(ingredient_count):\n                ingredient = st.text_input(f"Add your ingredient {i + 1}:", help = "Write with Capital letters e.g. Vodka")\n                quantity = st.text_input(f"Add quantity for {ingredient}:", help = "Write numeric Values e.g. 12")\n                unit = st.text_input(f"Add unit for {ingredient}:", help = "Write the abbreviations e.g. ml")\n                st.markdown("<br>" * 2, unsafe_allow_html=True)\n            \n                ingredient_list.append(ingredient)\n                quantity_list.append(quantity)\n                unit_list.append(unit)\n\n        # Use the function to set up all fields for the ingredient count        \n        add_ingredient(selected_count_ingredients)\n\n        # Form a dictionry for the inputs with corresponding column names as keys\n        ingredient_data = []\n    \n        for ingredient, quantity, unit in zip(ingredient_list, quantity_list, unit_list):\n            ingredient_data.append({\n                \'name\': name_add,\n                \'ingredient\': ingredient,\n                \'quantity\': quantity,\n                \'unit\': unit\n            })\n        \n        # Append the existing Dataframe\n        df_drink = df_drink.append(ingredient_data, ignore_index=True)\n        \n        # Due to the iteration the own crearion is added several times. We delete all those with nan values\n        df_drink = df_drink.fillna(\'Own Creation\')\n        \n        # Update the new dataframe within the original csv\n        df_drink.to_csv("df_drink_4.csv", mode=\'a\', index=False, header=False)\n\n\n    except Exception as e:\n        pass\n\n    \n# View 2 - Find your Drink:\n\n\nelif selected_view == "Find Your Drink":\n    \n    # Setup title\n    st.title("Find a Drink for your Leftovers üîé")\n    \n    # Import the updated Dataframe\n    df_drink = pd.read_csv("df_drink_4.csv", delimiter=",").astype(str)\n    \n    # Rename columns \n    df_drink.columns = [\'category\', \'name\', \'quantity\', "unit", "ingredient"]\n    \n    # Drop all dublicates coming from csv update in view 1\n    df_drink = df_drink.drop_duplicates()\n\n    # retrieve all ingredients one time and sort them alphabetically\n    ingredients_options = sorted(df_drink.iloc[:, 4].unique())\n\n    # Setup the multiselect and fill tem with the unique ingredients\n    selected_options_ingredients = st.multiselect(\'What has your fridge to offer?\', ingredients_options, help = help_button)\n\n    # Paragraph\n    st.markdown("<br>" * 1, unsafe_allow_html=True)\n\n    # Setup slider to chose the people count \n    selected_options_people = st.slider(\'How many are you?\', min_value=1, max_value=10, value=[1])\n    \n    # Save the selected ingredients in a list\n    selected_options_ingredients = [ingredient for ingredient in selected_options_ingredients]\n \n    # Setup columns to center certain content\n    col1, col2, col3 = st.columns([1.5, 0.8, 1.5])\n    with col2:\n        if st.button(\'Find your drink üîé\', key=\'find_drink_button\'):\n        \n            # Loading Spinner\n            with st.spinner("Searching for drinksüç∏"):\n                time.sleep(1)\n               \n                # Filter the Dataframe with ingredeint input from the user\n                filtered_drink = df_drink[df_drink[\'ingredient\'].isin(selected_options_ingredients)]\n            \n                # Covert and drop nan values\n                filtered_drink.replace({"nan": np.nan}, inplace=True)\n                filtered_drink.dropna(inplace=True)\n                df_drink.replace({"nan": np.nan}, inplace=True)\n                df_drink.dropna(inplace=True)\n\n                # Count frequencies for the names since every ingredient has a line and form a dictionary with count values as values\n                filtered_drink_list = filtered_drink.iloc[:, 1].tolist()\n                filtered_drink_dict = dict(Counter(filtered_drink_list))\n                \n                # Do the same with the Dataframe \n                drink_list = df_drink.iloc[:, 1].tolist()\n                drink_dict = dict(Counter(drink_list))\n    \n                # Find common names between the whole drink Dataframe and the user input and put them into a new dictionary\n                common_keys = drink_dict.keys() & filtered_drink_dict.keys()\n                combined_dict = {key: drink_dict[key] for key in common_keys}\n                 \n                # Divide the full ingredient count per drink from the user input by the ingredeint count from the full Dataframe to find matching percentages\n                result_dict = {}\n                for key in filtered_drink_dict.keys():\n                    result_dict[key] = filtered_drink_dict[key] / combined_dict[key]\n            \n                # Find the drink name with the biggest percentage\n                matching_drink = max(combined_dict, key=lambda k: result_dict[k])\n    \n    # Setup output if no ingredients are chosen and scale it with the people count\n    col1, col2, col3 = st.columns([1, 4.5, 1])\n    with col2:\n        if not selected_options_ingredients: \n                if selected_options_people[0] == 1:\n                    st.write("We can only offer you a recipe for a glass of tap water at this point üßä")\n                else:\n                    st.write(f"We can only offer you a recipe for {selected_options_people[0]} glasses of tap water at this point üßä")\n\n    try: \n  \n        # Filter the Datafrme with the matching drink name\n        df_filtered_matching_drink = df_drink[df_drink["name"] == matching_drink] \n\n        # Extract quantities for the matching drink and scale them with people count\n        quantities_matching_drink = df_filtered_matching_drink.iloc[:, 2]\n        quantities_matching_drink_scaled = quantities_matching_drink.astype(int) * selected_options_people\n    \n        # Update the Dataframe with the scaled quantities and loc quantities, units and ingredients\n        df_filtered_matching_drink["quantities_scaled"] = quantities_matching_drink_scaled\n        df_filtered_matching_drink = df_filtered_matching_drink.iloc[:, 3:]\n\n        # Combine the scaled quantities with the corresponding unit\n        quantities_with_units = df_filtered_matching_drink[\'quantities_scaled\'].astype(str) + " " + df_filtered_matching_drink[\'unit\']\n\n        # Filter the ingredients for the matching drink\n        ingrediets_matching_drink = df_filtered_matching_drink["ingredient"]\n    \n        # Centered bold output to display the matching drink name \n        centered_text_html = f"""\n            <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">\n                <h1>{matching_drink}</h1>\n            </div>\n        """\n        components.html(centered_text_html)\n        \n        # Output to display ingredients with quantities and units and add cocktail gifs \n        col1, col2, col3 = st.columns([1, 2, 1])\n        with col2:\n            for ingredient, quantity in zip(ingrediets_matching_drink, quantities_with_units):\n                st.markdown(f"<div style=\'text-align: center;\'><strong>{ingredient.title()}:</strong> {quantity}</div>", unsafe_allow_html=True)\n        with col1:\n            st.image("cocktail.gif", use_column_width=True)\n        with col3:\n            st.image("cocktail.gif", use_column_width=True)\n        \n        # Iterate over the ingredeints of the matching drinks and compare them to the input to find missing ingredients\n        not_listed_ingredients = [ingredient for ingredient in ingrediets_matching_drink if\n                                str(ingredient) not in selected_options_ingredients and not pd.isna(ingredient)]\n\n        # Retrieve purchasing links for the missing ingredients\n        link = search_products(not_listed_ingredients)\n    \n        # Setup individual output depending on the quantitiy of missing ingredients \n        if len(not_listed_ingredients) > 1:\n            st.markdown("<div style=\'text-align: center;\'><strong>The following ingredients are not in your fridge:</strong></div>", unsafe_allow_html=True)\n        elif len(not_listed_ingredients) == 1:\n            st.markdown("<div style=\'text-align: center;\'><strong>The following ingredient is not in your fridge:</strong></div>", unsafe_allow_html=True)\n        else:\n            st.markdown("<div style=\'text-align: center;\'><strong>You have all the ingredients. Have funüéâ</strong></div>", unsafe_allow_html=True)   \n    \n        # retrieve the first link and print them with the corresponding ingredient into an expander\n        col1, col2, col3 = st.columns([1, 2, 1])\n        for key, value in link.items():\n            with col2:\n                with st.expander(key):\n                    st.write(f"<div style=\'text-align: center;\'><a href=\'{value}\' target=\'_blank\'>{value}</a></div>", unsafe_allow_html=True)   \n        \n        # Form a new Dataframe with ingredients as columns and form boolean values for the occurance\n        selected_columns = ["name", "ingredient"]\n        df_drink_new = df_drink.loc[:, selected_columns]\n        df_machine_learning = pd.pivot_table(df_drink_new, index=\'name\', columns=\'ingredient\', aggfunc=lambda x: 1, fill_value=0)\n        df_machine_learning = df_machine_learning > 0\n\n        # Pre-Process the new Dataframe\n        df_machine_learning.reset_index(inplace=True)\n        df_machine_learning.columns.name = None\n        df_machine_learning.iloc[:, 1:] = df_machine_learning.iloc[:, 1:].astype(int)\n\n        # Form a correlation matrix and create a Dataframe\n        correlation_matrix = df_machine_learning.corr()\n        coefficients_df_1 = pd.DataFrame(columns=correlation_matrix.columns)\n\n        # Setup linear regression to forecast the correlation coefficients for each ingredient\n        for ingredient in selected_options_ingredients:\n\n            X = correlation_matrix.drop(columns=[ingredient])\n            y = correlation_matrix[ingredient]\n\n            model = LinearRegression()\n            model.fit(X, y)\n    \n            temp_df = pd.DataFrame(model.coef_, index=X.columns, columns=[ingredient]).T\n\n            coefficients_df_1 = pd.concat([coefficients_df_1, temp_df])\n\n        # Extract the max correlation per row\n        max_columns_per_row = coefficients_df_1.idxmax(axis=1)\n        \n        # Paragraph\n        st.markdown("<br>" * 1, unsafe_allow_html=True)\n        \n        # centered output to display the correlations\n        st.markdown("<div style=\'text-align: center;\'><strong>Here are some Correlations with your current selection (likely to appear together):</strong></div>", unsafe_allow_html=True)   \n        for col_name, value in max_columns_per_row.items():\n            st.write(f"<div style=\'text-align: center;\'>{col_name}: {value}</div>", unsafe_allow_html=True)\n    \n    except Exception as e:\n        pass\n\n\n# View 3 - Find a nearby Bar:    \n    \nelif selected_view == "Find a nearby Bar":\n    \n    #Setup Title\n    st.title("Find a Bar nearby your Location üåÉ")\n\n    try: \n    \n        # define function to retrieve coordinates for locations with an API and return latitude und longitude\n        def get_coordinates(location):\n            base_url = "https://nominatim.openstreetmap.org/search"\n            params = {\n                \'q\': location,\n                \'format\': \'json\',\n                \'limit\': 1\n            }\n\n            response = requests.get(base_url, params=params)\n            data = response.json()\n\n            if data:\n                first_result = data[0]\n                lat, lon = float(first_result[\'lat\']), float(first_result[\'lon\'])\n                return lat, lon\n    \n            else:\n                st.markdown("<p style=\'text-align: center;\'>Enter your location to start</p>", unsafe_allow_html=True)\n\n        # use lat und lon to retrieve a list of bars within an individualised distance\n        def search_nearby_bars(lat, lon, distance):\n            base_url = "https://overpass-api.de/api/interpreter"\n            query = f"""\n                [out:json];\n                node(around:{distance},{lat},{lon})["amenity"="pub"];\n                out center;\n            """\n\n            response = requests.post(base_url, data=query)\n            data = response.json()\n\n            # Print the Results\n            if \'elements\' in data and data[\'elements\']:\n                for element in data[\'elements\']:\n\n                    st.markdown(f"<p style=\'text-align: center;\'>{element[\'tags\'][\'name\']}</p>", unsafe_allow_html=True)\n\n            else:\n                st.markdown("<p style=\'text-align: center;\'>No Bars nearby</p>", unsafe_allow_html=True)\n         \n        # Steup input fields for location and distance \n        location = st.text_input("Add your Location (Street, City, Country):", help = "e.g Br√ºhlbleichestra√üe 8, St. Gallen, Switzerland")\n        distance = st.slider(\'How far are you willing to go in meters?\', min_value=1, max_value=5000, value=100)\n    \n        # Utilize the function to find lat und lon\n        coords = get_coordinates(location)\n        \n        # Utilize the function to retrieve nearby bars\n        if coords:\n            st.markdown("<p style=\'text-align: center;\'>Too lazy to shake cocktails yourself? <strong>Visit:</strong></p>", unsafe_allow_html=True)\n            st.markdown("<br>" * 1, unsafe_allow_html=True)\n            search_nearby_bars(*coords, distance)\n\n    except Exception as e:\n        pass\n')


# In[ ]:


get_ipython().system('streamlit run CS.py --server.headless true')


# !streamlit run CS.py --server.headless true
